# Cookie / Session / Token 인증 방식 종류
 ## Cookie 인증
      key-value 형식
      보통 클라이언트 브라우저에 저장되는 기록 정보 파일

  ### Cookie 인증 방식
      1. 클라이언트가 서버에 요청을 보냄
      2. 서버가 클라이언트의 요청에 대한 응답을 작성할 때 응답 헤더에 쿠키가 있는지 확인하고 없다면 생성한다.
      3. 클라이언트 측에 저장하고싶은 정보를 Set-Cookie에 담는다.
      4. 클라이언트는 이후 요청을 보낼 때마다, 저장된 쿠리를 요청 헤더의 Cookie에 담아 보내고
         서버는 이 정보를 바탕으로 클라이언트를 식별하거나 정보를 이용할 수 있다.

   ### Cookie 방식의 단점
        보안에 취약함. 요청 시 쿠키의 값을 그대로 보내기 때문에 유출 및 조작의 위험 존재
        용량 제한
        웹 브라우저마다 지원 형태가 달라 브라우저간 공유가 불가능하다
        네트워크의 부하가 심해진다

 ## Session 인증
      쿠키의 보안적인 이슈 때문에, 세션은 비밀번호 등 클라이언트의 민감한 인증정보를 브라우저가 아닌 서버 측에 저장하고 관리

      세션 객체는 Key에 해당하는 SESSION ID와 이에 대응하는 Value로 구성되어 있다
      Value에는 세션 생성 시간, 마지막 접근 시간 및 User가 저장한 속성 등이 Map 형태로 저장된다

  ### Session 인증 방식
        1. 유저가 웹사이트에서 로그인하면 세션이 서버 상에 저장된다
        2. 서버에서 브라우저 쿠키에 Session Id를 저장한다
        3. 쿠키에 정보가 담겨있기 떄문에 브라우저는 해당 사이트에 대한 모든 Request에 Session Id를 쿠키에 담아 전송한다
        4. 서버는 클라이언트가 보낸 Session Id와 서버에서 관리하는 Session Id를 비교하여 인증을 수행한다

  ### Session 방식의 단점
        Session Id를 탈취당할 위험 존재
        서버에서 세션 저장소를 사용하므로 요청이 많아지면 서버의 부하가 심해진다

## Token 인증
      클라이언트가 서버에 접속을 하면 서버에서 해당 클라이언트에 인증되었다는 의미로 '토큰'을 부여한다.
      이 토큰은 유일하며 토큰을 발급받은 클라이언트는 다시 서버에 요청을 보낼 때 헤더에 토큰을 담아 요청한다
      서버는 토큰을 서버에서 제공한 토큰과의 일치 여부를 체크하여 인증한다

      기존의 세션기반 인증은 서버가 파일이나 데이터베이스에 세션 정보를 가지고 있어야 하지만 토큰은 서버가 아닌
      클라이언트에 저장되기 때문에 서버의 부담을 덜 수 있다

      앱에서는 쿠키와 세션이 없기 때문에 토큰 방식을 많이 사용한다

  ### Token 인증 방식
      1. 사용자가 로그인을 하면 서버 측에서 토큰을 발급한다.
      2. 클라이언트는 서버 측에서 전달받은 토큰을 저장하고 요청 시 마다 헤더에 포함시켜 전달
      3. 서버는 토큰을 검증하고 요청에 응답한다

   ### Token 방식의 단점
      쿠키 / 세션과 다르게 토큰 자체의 데이터 길이가 길어 네트워크 부하가 심해질 수 있다
      payload 자체는 암호화되지 않기 때문에 중요한 정보는 담을 수 없다
      토큰을 탈취당하면 대처하기 어려워 사용 기간 제한을 설정하는 방식으로 사용한다

# JWT (Json Web Token) 란?
      JWT란 인증에 필요한 정보들을 암호화시킨 JSON토큰
      JWT 기반 인증은 JWT토큰을 HTTP 헤더에 담아 서버가 클라이언트를 식별하는 방식
      JWT는 JSON데이터를 Base564 URL-safe Encode를 통해 인코딩하여 직렬화한 것

## JWT 구조
  #### 헤더(Header) . 내용(Payload) . 서명(Signature)
      헤더에는 JWT에서 사용할 타입과 해시 알고리즘의 종류가 존재
      Payload에는 서버에서 첨부한 사용자 권한 정보와 데이터 존재 (Claim)
      Signature에는 헤더, payload를 Base64-URL-safe Encode 한 이후 헤더에 명시된 해시함수를 적용하고, 개인키로 서명한 전자서명 존재

      Header 
      {
          "alg": "HS256"
          "typ": "JWT"
      }

      Payload
      {
          "sub": "1234567890"
          "name": "hee seok"
          "iat": 15162351
      }

      Signature = 
        [ Base64URL(header) + . + Base64URL(payload) + server's private key ] HS256(헤더에 명시된 알고리즘으로 암호화)
        서버의 개인키가 유출되지 않는 이상 복호화 불가능

        탈취당한 토큰의 payload가 수정되면 서버에서 유효성 검사 시에 signature가 불일치하므로 조작되었음을 판단 가능
     

        
