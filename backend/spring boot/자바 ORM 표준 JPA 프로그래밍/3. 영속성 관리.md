# 엔티티 매니저 팩토리와 엔티티 매니저
  ## 엔티티 매니저 팩토리
```java
EntityManagerFactory emf = 
    Persistence.createEntityMangerFactory("jpabook");
```
    데이터베이스를 하나만 사용하는 애플리케이션은 일반적으로 EntityManagerFactory를 하나만 생성
    persistence.xml에 있는 정보를 바탕으로 EntityManagerFactory를 생성한다.
    엔티티 매니저 팩토리는 만드는 데 비용이 상당히 크고 엔티티 매니저를 생성한다.
    여러 스레드가 동시에 접근해도 안전하므로 스레드 간에 공유해도 된다.

  ## 엔티티 매니저
```java    
EntityManager em = emf.createEntityManager();
```
    엔티티 매니저는 데이터베이스 연결이 꼭 필요한 시점까지 커넥션을 얻디 않는다.
    예를 들어 트랜잭션을 시작할 때 커넥션을 획득한다.
    엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드 간에 공유해서는 안된다.

# 영속성 컨텍스트
    persistence context. 엔티티를 영구 저장하는 환경
    엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트로 엔티티를 보관하고 관리한다.
    영속성 컨텍스트는 엔티티 매니저를 생성할 때 하나 만들어지고 엔티티 매니저를 통해 영속성 컨텍스트 관리.

# 엔티티의 생명주기
  - 비영속(new / transient) : 영속성 컨텍스트와 전혀 관계가 없는 상태
  - 영속(managed) : 영속성 컨텍스트에 저장된 상태. 영속성 컨텍스트가 관리하는 엔티티
  - 준영속(detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태
  - 삭제(removed) : 삭제된 상태. 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제한다.

# 영속성 컨텍스트의 특징
    영속성 컨텍스트는 엔티티를 식별자 값(@Id로 테이블의 기본 키와 매핑한 값)으로 구분한다.
    따라서 영속 상태는 식별자 값이 반드시 있어야 한다.

    영속성 컨텍스트가 엔티티를 관리할 때 장점
        1. 1차 캐시 (@Id를 통해 엔티티 인스턴스를 찾을 수 있다.)
        2. 동일성 보장
        3. 트랜잭션을 지원하는 쓰기 지원
        4. 변경 감지 (플러시 시점에 영속성 컨텍스트에 저장된 스냅샷과 엔티티를 비)
        5. 지연 로딩

# 플러시
    플러시(flush())는 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영한다(동기화).

    1. 변경 감지가 동작해서 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교해서 수정된 엔티티를 찾는다.
        수정된 엔티티는 수정 쿼리를 만들어 쓰기 지연 SQL 저장소에 등록한다.
    2. 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송한다.

    영속성 컨텍스트를 플러시 하는 방법
    1. em.flush()
    2. 트랜잭션 커밋
    3. JPQL 쿼리 실행
    
