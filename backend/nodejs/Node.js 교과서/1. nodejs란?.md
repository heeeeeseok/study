### Node.js는 Chorme V8 Javascript 엔진으로 빌드된 자바스크립트 런타임

    노드를 통해 다양한 자바스크립트 어플리케이션을 실행 가능하지만, 서버 어플리케이션을 실행하는 데 제일 많이 사용

    노드는 V8과 더불어 libuv 라이브러리를 사용
    libuv는 노드의 특성인 이벤트 기반, 논블로킹 I/O 모델을 구현

### 이벤트 기반

    이벤트 발생 시 이벤트 리스너에 등록된 콜백함수를 호출하고 이벤트를 다 처리하면 다음 이벤트가 발생할 때까지 대기
    이벤트 루프 : 이벤트 발생 시 호출할 콜백 함수들을 관리하고, 호출된 콜백 함수의 실행 순서를 결정하는 역할을 담당함
    백그라운드 : 타이머나 이벤트 리스너들이 대기하는 곳으로 여러 작업이 동시에 실행될 수 있음
    태스크 큐 (콜백 큐) : 이벤트 발생 후, 백그라운드에서는 태스크 큐로 타이머나 이벤트 리스너의 콜백 함수를 전달

### 논블로킹 I/O

    I/O 작업은 동시에 처리될 수 있다
    논블로킹이란 이전 작업이 완료될 때까지 대기하지 않고 다음 작업을 수행하는 것을 의미
    노드는 I/O 작업을 백그라운드로 넘겨 동시에 처리함
    동시에 처리할 수 있는 작업과 그렇지 못한 작업을 고려하여 코딩하는 것이 중요함
    비동기(asyncrhonized) 방식과 유사

### 싱글 스레드

    프로세스 : os에서 할당하는 작업의 단위. 프로세스 간에는 메모리와 자원을 공유하지 않음
    스레드 : 프로세스 내에서 실행되는 흐름의 단위. 스레드는 부모 프로세스의 자원을 공유하고 같은 주소의 메모리에 접근 가능

    노드를 실행하면 프로세스를 하나 생성하고 그 프로세스가 스레드들을 생성하는데, 직접 제어 가능한 스레드는 하나 뿐이다
    따라서 블로킹이 심하게 일어나는 작업을 처리할 경우에는 논블로킹 방법을 활용해야 함

    노드가 싱글 스레드로 동작하지 않는 경우 :
      1. 스레드 풀 : 암호화나 파일 입출력, 압축 등을 실행할 때 스스로 멀티 스레드를 사용
      2. 워커 스레드 : 직접 멀티 스레드를 다룰 수 있으며 CPU 작업이 많은 경우에 활용


    노드는 기본적으로 싱글 스레드, 논블로킹 모델로 구현되기 때문에 CPU 부하가 큰 작업에는 적합하지 않고
    채팅이나 주삭차트 등 작은 데이터를 실시간으로 주고받는 i/O를 처리하는 곳에 적합

    싱글 스레드 방식이기 때문에 에러가 났을 때 제대로 처리하지 못하면 서버 전체가 멈추는 단점

### 프로미스

    ES2015부터 JS와 노드의 API들이 콜백 대신 promise 기반으로 재구성됨

```javascript
const condition = true;
const promise = new Promise((resolve, reject) => {
  if (condition) {
    resolve('성공');
  } else {
    recject('실패');
  }
});

promise
  .then((message) => {
    console.log(message); // 성공(resolve)
  })
  .else((error) => {
    console.error(error); // 실패(reject)
  })
  .finally(() => {
    console.log('무조건 실행'); // 끝나고 무조건 실행
  })
```
```javascript
function findAndSaveUser(Users) {
  Users.findOne({})
    .then((user) => {
      user.name = 'zero';
      return user.save();
    })
    .then((user) => {
      return Users.findOne({ gender: 'm' });
    })
    .then((user) => {
    })
    .catch(err => {
      console.error(err);
    });
}
```


